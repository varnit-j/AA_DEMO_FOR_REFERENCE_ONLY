
# Flight Booking Microservices Architecture

## Overview
This document outlines the decomposition of the monolithic flight booking application into 4 independent microservices for better scalability, maintainability, and fault tolerance.

## Microservices Architecture

### 1. Backend Service (Core Flight Booking)
**Port**: 8001
**Responsibility**: Core flight operations and user management
**Database**: PostgreSQL (flights_db)

#### Components:
- User authentication and management
- Flight search and booking
- Airport and place management
- Ticket generation and management
- Order coordination

#### Files/Modules:
```
backend-service/
├── flight/
│   ├── models.py (User, Place, Flight, Passenger, Ticket)
│   ├── views.py (search, booking, user management)
│   ├── utils.py
│   └── admin.py
├── capstone/
│   ├── settings.py
│   ├── urls.py
│   └── utils.py
├── Data/ (airports, flights CSV)
├── manage.py
└── requirements.txt
```

#### API Endpoints:
- `GET /api/flights/search` - Search flights
- `POST /api/flights/book` - Book flight
- `GET /api/tickets/{id}` - Get ticket details
- `POST /api/users/register` - User registration
- `POST /api/users/login` - User authentication
- `GET /api/places/search` - Search airports/cities

### 2. Payment Service
**Port**: 8002
**Responsibility**: Payment processing and financial transactions
**Database**: PostgreSQL (payments_db)

#### Components:
- Stripe payment integration
- Mock banking system
- Payment validation and processing
- Transaction history
- Refund management

#### Files/Modules:
```
payment-service/
├── apps/
│   ├── payments/
│   │   └── stripe_client.py
│   └── banking/
│       ├── models.py (BankCard, PaymentTransaction)
│       └── service.py (MockBankingService)
├── payments/
│   ├── views.py
│   ├── webhooks.py
│   └── urls.py
├── settings.py
└── requirements.txt
```

#### API Endpoints:
- `POST /api/payments/create-intent` - Create payment intent
- `POST /api/payments/process` - Process payment
- `POST /api/payments/webhook` - Stripe webhooks
- `GET /api/payments/history/{user_id}` - Payment history
- `POST /api/payments/refund` - Process refund

### 3. Loyalty Service
**Port**: 8003
**Responsibility**: Loyalty program and points management
**Database**: PostgreSQL (loyalty_db)

#### Components:
- Points earning and redemption
- Tier management
- Transaction history
- Points expiry handling
- Loyalty dashboard

#### Files/Modules:
```
loyalty-service/
├── apps/
│   └── loyalty/
│       ├── models.py (LoyaltyTier, LoyaltyAccount, PointsTransaction)
│       ├── service.py (LoyaltyService)
│       ├── views.py
│       ├── admin.py
│       └── management/commands/
├── settings.py
└── requirements.txt
```

#### API Endpoints:
- `GET /api/loyalty/account/{user_id}` - Get loyalty account
- `POST /api/loyalty/earn` - Award points
- `POST /api/loyalty/redeem` - Redeem points
- `GET /api/loyalty/history/{user_id}` - Transaction history
- `GET /api/loyalty/tiers` - Get tier information

### 4. UI Service (Frontend + API Gateway)
**Port**: 8000
**Responsibility**: User interface and API orchestration
**Database**: None (stateless)

#### Components:
- Frontend templates and static files
- API Gateway for routing requests
- Session management
- Request orchestration

#### Files/Modules:
```
ui-service/
├── templates/
│   └── flight/ (all HTML templates)
├── static/
│   ├── css/
│   ├── js/
│   └── img/
├── gateway/
│   ├── views.py (API orchestration)
│   ├── auth.py (authentication middleware)
│   └── urls.py
├── settings.py
└── requirements.txt
```

#### Routes:
- `/*` - Frontend pages (proxy to backend services)
- `/api/gateway/*` - API Gateway routes

## Inter-Service Communication

### Service Discovery
- Each service registers with a service registry
- Services communicate via HTTP REST APIs
- Load balancing handled by API Gateway

### Authentication Flow
1. User authenticates via UI Service
2. JWT token generated by Backend Service
3. Token validated by all services
4. Shared secret for service-to-service communication

### Data Flow Examples

#### Flight Booking Flow:
1. **UI Service** → **Backend Service**: Search flights
2. **UI Service** → **Backend Service**: Create booking
3. **Backend Service** → **Payment Service**: Process payment
4. **Payment Service** → **Loyalty Service**: Award points
5. **UI Service** ← **Backend Service**: Booking confirmation

#### Hybrid Payment Flow:
1. **UI Service** → **Loyalty Service**: Check points balance
2. **UI Service** → **Loyalty Service**: Redeem points
3. **UI Service** → **Payment Service**: Process remaining amount
4. **Payment Service** → **Backend Service**: Confirm payment

## Database Strategy

### Database per Service (Recommended)
- **flights_db**: Backend Service (Users, Flights, Tickets)
- **payments_db**: Payment Service (Transactions, Bank Cards)
- **loyalty_db**: Loyalty Service (Points, Tiers, Transactions)

### Data Consistency
- **Eventual Consistency**: For cross-service operations
- **Event-Driven Architecture**: Services publish events for state changes
- **Saga Pattern**: For distributed transactions

## Deployment Strategy

### Docker Configuration
Each service will have its own Dockerfile and can be deployed independently.

### Environment Variables
- Service URLs for inter-service communication
- Database connection strings
- API keys (Stripe, etc.)
- JWT secrets

## Migration Plan

1. **Phase 1**: Create service structure and basic APIs
2. **Phase 2**: Migrate data and implement inter-service communication
3. **Phase 3**: Deploy services and test end-to-end functionality
4. **Phase 4**: Optimize and monitor performance

## Benefits

- **Scalability**: Each service can be scaled independently
- **Fault Tolerance**: If one service fails, others continue running
- **Technology Diversity**: Each service can use different technologies
- **Team Independence**: Different teams can work on different services
- **Deployment Flexibility**: Services can be deployed independently